---
layout: post
title:  "J2EE Patterns - Intercepting Filter"
date:   2021-03-03 00:00:00 +0900
category: design-pattern
---
원본: https://www.oracle.com/java/technologies/intercepting-filter.html

# Intercepting Filter

## Context
프레젠테이션 계층은 다양한 유형의 처리가 필요한 요청들을 처리할 수 있는 매커니즘이 필요하다. 어떤 요청들은 단순히 유효한 핸들러 컴포넌트로 전달되지만 그 외에 다른 요청들은 요청이 완료되기 전에 수정, 감사, 압축을 해제하는 등의 추가작업이 필요하다

## Problem
클라이언트 웹 요청, 응답의 전처리 후처리가 필요하다. 웹 어플리케이션에 요청이 들어오면 주요 처리 단계에 진입하기 전까지 많은 단계를 거치게 된다.
- 클라이언트가 인증되었는가?
- 클라이언트가 유효한 세션을 가지고 있는가?
- 클라이언트의 IP주소가 신뢰할 수 있는 네트워크에서 온건가?
- 요청한 패스가 제약조건을 위반했는가?
- 클라이언트가 데이터를 전송할 때 어떤 encoding을 사용하였는가?
- 클라이언트의 브라우져 타입을 서버가 지원하는가?

이러한 검사 중 일부는 테스트이므로 처리를 계속할지 여부를 선택하는 예 아니오로 결과가 나온다. 다른 검사는 들어오는 데이터 스트림을 처리에 적합한 형식으로 변환합니다. 기존 해결방법은 일련의 조건부 검사로 구성되어 있고 실패하게 되면 요청을 중단한다. 중첩된 if/else문이 기존 전략이었고, 이 전략은 코드를 취약하게 만들고 복사 붙여넣기 식의 안 좋은 프로그래밍 스타일로 가게 한다. 필터링의 전반적인 흐름이나 동작이 응용 프로그램으로 컴파일 되기 때문이다.

Interceptin Filter는 이 문제를 유연하게 해결할 수 있고 눈에 띄지 않는 방식 즉, 새로운 프로세스를 추가하거나 변경, 삭제하는 것을 간단하게 할 수 있고 각 컴포넌트들은 특정한 필터링에 대한 동작을 수행할 수 있다.

## Force
- data-encoding을 검사하거나 logging을 하는 작업 등의 공통된 처리는 하나의 요청별로 완료된다.
- 공통의 로직들은 중앙집중화가 필요하다.
- 서비스는 기존에 존재하는 컴포넌트에 영향을 주지 않고 쉽게 추가되거나 삭제될 수 있어야 하고, 다양한 조합으로 사용 가능해야 한다. 예를 들어
    - 로그인과 인증
    - 특정 클라이언트에 대한 정보들을 디버깅하거나 다른 데이터 포맷으로 변환할 수 있어야 한다.
    - 입력된 인코딩을 변환하거나 디코딩 할 수 있어야 한다.

## Solution
요청을 처리하는 핵심 코드를 변경할 필요 없이, 표준 방식으로 공통 서비스를 처리하기 위한 플러그형 필터를 생성한다. 필터들은 들어오는 요청과 응답을 중간에 잡아채서 전처리와 후처리를 허용한다. 우리는 기존 코드를 변경하지 않고도 눈에 잘 띄지 않게 이러한 필터들을 추가하고 제거할 수 있어야 한다.  

우리는 security, logging, debugging과 같은 다양한 공통 서비스를 가지고 주요 처리와 연동해야 한다. 이러한 필터들은 메인 어플리케이션 코드와 분리된 독립적인 구성 요소이다. 그리고 선언적으로 추가하거나 제거할 수 있어야 한다. 예를 들어 배포 설정 파일은 체이닝 되어 있는 필터들을 준비하는데 있어서 수정할 수 있어야 한다. 이와 같은 설정 파일은 이 필터 체인에 의하여 특정한 URL로 매핑되는 것을 추가할 수 있어야 한다. 클라이언트가 이미 설정된 특정 URL와 일치하는 resource를 요청할 때, 체이닝 되어있는 필터들은 대상 리소스가 호출되기 전에 각자 자기만의 프로세스를 순서대로 실행한다.

<br />

### Structrue  
Intercepting Filter class diagram