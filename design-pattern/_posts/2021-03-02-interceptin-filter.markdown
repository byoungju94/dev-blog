---
layout: post
title:  "J2EE Patterns - Intercepting Filter"
date:   2021-03-03 00:00:00 +0900
category: design-pattern
---
원본: https://www.oracle.com/java/technologies/intercepting-filter.html

# Intercepting Filter

## Context
프레젠테이션 계층은 다양한 유형의 처리가 필요한 요청들을 처리할 수 있는 매커니즘이 필요하다. 어떤 요청들은 단순히 유효한 핸들러 컴포넌트로 전달되지만 그 외에 다른 요청들은 요청이 완료되기 전에 수정, 감사, 압축을 해제하는 등의 추가작업이 필요하다

## Problem
클라이언트 웹 요청, 응답의 전처리 후처리가 필요하다. 웹 어플리케이션에 요청이 들어오면 주요 처리 단계에 진입하기 전까지 많은 단계를 거치게 된다.
- 클라이언트가 인증되었는가?
- 클라이언트가 유효한 세션을 가지고 있는가?
- 클라이언트의 IP주소가 신뢰할 수 있는 네트워크에서 온건가?
- 요청한 패스가 제약조건을 위반했는가?
- 클라이언트가 데이터를 전송할 때 어떤 encoding을 사용하였는가?
- 클라이언트의 브라우져 타입을 서버가 지원하는가?

이러한 검사 중 일부는 테스트이므로 처리를 계속할지 여부를 선택하는 예 아니오로 결과가 나온다. 다른 검사는 들어오는 데이터 스트림을 처리에 적합한 형식으로 변환합니다. 기존 해결방법은 일련의 조건부 검사로 구성되어 있고 실패하게 되면 요청을 중단한다. 중첩된 if/else문이 기존 전략이었고, 이 전략은 코드를 취약하게 만들고 복사 붙여넣기 식의 안 좋은 프로그래밍 스타일로 가게 한다. 필터링의 전반적인 흐름이나 동작이 응용 프로그램으로 컴파일 되기 때문이다.

Interceptin Filter는 이 문제를 유연하게 해결할 수 있고 눈에 띄지 않는 방식 즉, 새로운 프로세스를 추가하거나 변경, 삭제하는 것을 간단하게 할 수 있고 각 컴포넌트들은 특정한 필터링에 대한 동작을 수행할 수 있다.

## Force
- data-encoding을 검사하거나 logging을 하는 작업 등의 공통된 처리는 하나의 요청별로 완료된다.
- 공통의 로직들은 중앙집중화가 필요하다.
- 서비스는 기존에 존재하는 컴포넌트에 영향을 주지 않고 쉽게 추가되거나 삭제될 수 있어야 하고, 다양한 조합으로 사용 가능해야 한다. 예를 들어
    - 로그인과 인증
    - 특정 클라이언트에 대한 정보들을 디버깅하거나 다른 데이터 포맷으로 변환할 수 있어야 한다.
    - 입력된 인코딩을 변환하거나 디코딩 할 수 있어야 한다.

## Solution
- 
